<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>宋军亮的技术博客 on 宋军亮的技术博客</title>
    <link>/</link>
    <description>Recent content in 宋军亮的技术博客 on 宋军亮的技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Sep 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>pywin32控制你的打印机</title>
      <link>/2019/%E9%87%87%E7%94%A8pywin32%E6%8E%A7%E5%88%B6%E4%BD%A0%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E9%87%87%E7%94%A8pywin32%E6%8E%A7%E5%88%B6%E4%BD%A0%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/</guid>
      <description>&lt;p&gt;pywin23控制打印机&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>bs4</title>
      <link>/2019/python-beautifulsoup4/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/python-beautifulsoup4/</guid>
      <description>

&lt;p&gt;Beautiful Soup 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup 会帮你节省数小时甚至数天的工作时间.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装
以下都是在 python2.7 中进行测试的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以直接使用 pip 安装：&lt;/p&gt;

&lt;p&gt;$ pip install beautifulsoup4
BeautifulSoup 不仅支持 HTML 解析器,还支持一些第三方的解析器，如，lxml，XML，html5lib 但是需要安装相应的库。&lt;/p&gt;

&lt;p&gt;$ pip install lxml&lt;/p&gt;

&lt;p&gt;$ pip install html5lib
2. 开始使用
Beautiful Soup 的功能相当强大，但我们只介绍经常使用的功能。&lt;/p&gt;

&lt;p&gt;简单用法
将一段文档传入 BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;from bs4 import BeautifulSoup&lt;/p&gt;

&lt;p&gt;soup = BeautifulSoup(&amp;rdquo;&lt;html&gt;&lt;body&gt;&lt;p&gt;data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;soup
&lt;html&gt;&lt;body&gt;&lt;p&gt;data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/p&gt;

&lt;p&gt;soup(&amp;lsquo;p&amp;rsquo;)
[&lt;p&gt;data&lt;/p&gt;]
首先传入一个 html 文档，soup 是获得文档的对象。然后,文档被转换成 Unicode ,并且 HTML 的实例都被转换成 Unicode 编码。然后,Beautiful Soup 选择最合适的解析器来解析这段文档,如果手动指定解析器那么 Beautiful Soup 会选择指定的解析器来解析文档。但是一般最好手动指定解析器，并且使用 requests 与 BeautifulSoup 结合使用， requests 是用于爬取网页源码的一个库，此处不再介绍，requests 更多用法请参考 Requests 2.10.0 文档 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;要解析的文档是什么类型: 目前支持, html, xml, 和 html5
指定使用哪种解析器: 目前支持, lxml, html5lib, 和 html.parser&lt;/p&gt;

&lt;p&gt;from bs4 import BeautifulSoup
import requests&lt;/p&gt;

&lt;p&gt;html = requests.get(‘&lt;a href=&#34;http://www.jianshu.com/’).content&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.jianshu.com/’).content&lt;/a&gt;&lt;br /&gt;
soup = BeautifulSoup(html, &amp;lsquo;html.parser&amp;rsquo;, from_encoding=&amp;lsquo;utf-8&amp;rsquo;)
result = soup(&amp;lsquo;div&amp;rsquo;)
对象的种类
Beautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构,每个节点都是 Python 对象,所有对象可以归纳为 4 种: Tag , NavigableString , BeautifulSoup , Comment .&lt;/p&gt;

&lt;p&gt;Tag：通俗点讲就是 HTML 中的一个个标签，像上面的 div，p。每个 Tag 有两个重要的属性 name 和 attrs，name 指标签的名字或者 tag 本身的 name，attrs 通常指一个标签的 class。
NavigableString：获取标签内部的文字，如，soup.p.string。
BeautifulSoup：表示一个文档的全部内容。
Comment：Comment 对象是一个特殊类型的 NavigableString 对象，其输出的内容不包括注释符号.
示例
下面是一个示例，带你了解 Beautiful Soup 的常见用法：&lt;/p&gt;

&lt;p&gt;import sys&lt;br /&gt;
reload(sys)&lt;br /&gt;
sys.setdefaultencoding(&amp;lsquo;utf-8&amp;rsquo;)
from bs4 import BeautifulSoup
import requests&lt;/p&gt;

&lt;p&gt;html_doc = &amp;ldquo;&amp;rdquo;&amp;rdquo;
&lt;head&gt;
      &lt;meta charset=&#34;utf-8&#34;&gt;
      &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=Edge&#34;&gt;
    &lt;title&gt;首页 &lt;/title&gt;
&lt;/head&gt;&lt;/p&gt;

&lt;p&gt;&lt;body class=&#34;output fluid zh cn win reader-day-mode reader-font2 &#34; data-js-module=&#34;recommendation&#34; data-locale=&#34;zh-CN&#34;&gt;&lt;/p&gt;

&lt;ul class=&#34;article-list thumbnails&#34;&gt;

  &lt;li class=have-img&gt;
      &lt;a class=&#34;wrap-img&#34; href=&#34;/p/49c4728c3ab2&#34;&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/2442470-745c6471c6f8258c.jpg?imageMogr2/auto-orient/strip%7CimageView2/1/w/300/h/300&#34; alt=&#34;300&#34; /&gt;&lt;/a&gt;
    &lt;div&gt;
      &lt;p class=&#34;list-top&#34;&gt;
        &lt;a class=&#34;author-name blue-link&#34; target=&#34;_blank&#34; href=&#34;/users/0af6b163b687&#34;&gt;阿随向前冲&lt;/a&gt;
        &lt;em&gt;·&lt;/em&gt;
        &lt;span class=&#34;time&#34; data-shared-at=&#34;2016-07-27T07:03:54+08:00&#34;&gt;&lt;/span&gt;
      &lt;/p&gt;
      &lt;h4 class=&#34;title&#34;&gt;&lt;a target=&#34;_blank&#34; href=&#34;/p/49c4728c3ab2&#34;&gt; 只装了这六款软件，工作就高效到有时间逛某宝刷某圈&lt;/a&gt;&lt;/h4&gt;
      &lt;div class=&#34;list-footer&#34;&gt;
        &lt;a target=&#34;_blank&#34; href=&#34;/p/49c4728c3ab2&#34;&gt;
          阅读 1830
&lt;/a&gt;        &lt;a target=&#34;_blank&#34; href=&#34;/p/49c4728c3ab2#comments&#34;&gt;
           · 评论 35
&lt;/a&gt;        &lt;span&gt; · 喜欢 95&lt;/span&gt;
          &lt;span&gt; · 打赏 1&lt;/span&gt;
        
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/body&gt;
&amp;ldquo;&amp;rdquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;soup = BeautifulSoup(html_doc, &amp;lsquo;html.parser&amp;rsquo;, from_encoding=&amp;lsquo;utf-8&amp;rsquo;)&lt;/p&gt;

&lt;h1 id=&#34;查找所有有关的节点&#34;&gt;查找所有有关的节点&lt;/h1&gt;

&lt;p&gt;tags = soup.find&lt;em&gt;all(&amp;lsquo;li&amp;rsquo;, class&lt;/em&gt;=&amp;ldquo;have-img&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;for tag in tags:
        image = tag.img[&amp;lsquo;src&amp;rsquo;]
        article_user = tag.p.a.get_text()
        article_user_url = tag.p.a[&amp;lsquo;href&amp;rsquo;]&lt;br /&gt;
        created = tag.p.span[&amp;lsquo;data-shared-at&amp;rsquo;]&lt;br /&gt;
        article_url = tag.h4.a[&amp;lsquo;href&amp;rsquo;]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # 可以在查找的 tag 下继续使用 find_all()
    tag_span = tag.div.div.find_all(&#39;span&#39;)

    likes = tag_span[0].get_text(strip=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BeautifulSoup 主要用来遍历子节点及子节点的属性，通过点取属性的方式只能获得当前文档中的第一个 tag，例如，soup.li。如果想要得到所有的&lt;li&gt; 标签,或是通过名字得到比一个 tag 更多的内容的时候,就需要用到 find_all()，find_all() 方法搜索当前 tag 的所有 tag 子节点,并判断是否符合过滤器的条件find_all() 所接受的参数如下：&lt;/p&gt;

&lt;p&gt;find_all( name , attrs , recursive , string , **kwargs )
按 name 搜索: name 参数可以查找所有名字为 name 的 tag,字符串对象会被自动忽略掉:&lt;/p&gt;

&lt;p&gt;soup.find_all(&amp;ldquo;li&amp;rdquo;)
按 id 搜索: 如果包含一个名字为 id 的参数,搜索时会把该参数当作指定名字 tag 的属性来搜索:&lt;/p&gt;

&lt;p&gt;soup.find_all(id=&amp;lsquo;link2&amp;rsquo;)
按 attr 搜索：有些 tag 属性在搜索不能使用,比如 HTML5 中的 data-* 属性，但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的 tag:&lt;/p&gt;

&lt;p&gt;data_soup.find&lt;em&gt;all(attrs={&amp;ldquo;data-foo&amp;rdquo;: &amp;ldquo;value&amp;rdquo;})
按 CSS 搜索: 按照 CSS 类名搜索 tag 的功能非常实用,但标识CSS 类名的关键字 class 在 Python 中是保留字,使用 class 做参数会导致语法错误.从 Beautiful Soup 的 4.1.1 版本开始,可以通过 class&lt;/em&gt; 参数搜索有指定 CSS 类名的 tag:&lt;/p&gt;

&lt;p&gt;soup.find&lt;em&gt;all(&amp;lsquo;li&amp;rsquo;, class&lt;/em&gt;=&amp;ldquo;have-img&amp;rdquo;)
string 参数：通过 string 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, string 参数接受 字符串 , 正则表达式 , 列表, True 。 看例子:&lt;/p&gt;

&lt;p&gt;soup.find_all(&amp;ldquo;a&amp;rdquo;, string=&amp;ldquo;Elsie&amp;rdquo;)
recursive 参数：调用 tag 的 find_all() 方法时,Beautiful Soup 会检索当前 tag 的所有子孙节点,如果只想搜索 tag 的直接子节点,可以使用参数 recursive=False .&lt;/p&gt;

&lt;p&gt;soup.find_all(&amp;ldquo;title&amp;rdquo;, recursive=False)
find_all() 几乎是 Beautiful Soup中最常用的搜索方法,也可以使用其简写方法，以下代码等价：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;soup.find_all(&amp;quot;a&amp;quot;)
soup(&amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get_text()
如果只想得到 tag 中包含的文本内容,那么可以用 get_text() 方法,这个方法获取到 tag 中包含的所有文版内容包括子孙 tag 中的内容,并将结果作为 Unicode 字符串返回:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tag.p.a.get_text()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>单链表</title>
      <link>/2019/%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;p&gt;单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。
1.表元素域elem用来存放具体的数据。
2.链接域next用来存放下一个节点的位置
3.变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SingleNode(object):
    &amp;quot;&amp;quot;&amp;quot;单链表的结点&amp;quot;&amp;quot;&amp;quot;
    def __init__(self,item):
        # _item存放数据元素
        self.item = item
        # _next是下一个节点的标识
        self.next = None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单链表的操作&lt;/p&gt;

&lt;p&gt;is_empty() 链表是否为空
length() 链表长度
travel() 遍历整个链表
add(item) 链表头部添加元素
append(item) 链表尾部添加元素
insert(pos, item) 指定位置添加元素
remove(item) 删除节点
search(item) 查找节点是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SingleLinkList(object):
    &amp;quot;&amp;quot;&amp;quot;单链表&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        self._head = None

    def is_empty(self):
        &amp;quot;&amp;quot;&amp;quot;判断链表是否为空&amp;quot;&amp;quot;&amp;quot;
        return self._head == None

    def length(self):
        &amp;quot;&amp;quot;&amp;quot;链表长度&amp;quot;&amp;quot;&amp;quot;
        # cur初始时指向头节点
        cur = self._head
        count = 0
        # 尾节点指向None，当未到达尾部时
        while cur != None:
            count += 1
            # 将cur后移一个节点
            cur = cur.next
        return count

    def travel(self):
        &amp;quot;&amp;quot;&amp;quot;遍历链表&amp;quot;&amp;quot;&amp;quot;
        cur = self._head
        while cur != None:
            print cur.item,
            cur = cur.next
        print &amp;quot;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;头部添加元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def add(self, item):
    &amp;quot;&amp;quot;&amp;quot;头部添加元素&amp;quot;&amp;quot;&amp;quot;
    # 先创建一个保存item值的节点
    node = SingleNode(item)
    # 将新节点的链接域next指向头节点，即_head指向的位置
    node.next = self._head
    # 将链表的头_head指向新节点
    self._head = node

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尾部添加元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def append(self, item):
    &amp;quot;&amp;quot;&amp;quot;尾部添加元素&amp;quot;&amp;quot;&amp;quot;
    node = SingleNode(item)
    # 先判断链表是否为空，若是空链表，则将_head指向新节点
    if self.is_empty():
        self._head = node
    # 若不为空，则找到尾部，将尾节点的next指向新节点
    else:
        cur = self._head
        while cur.next != None:
            cur = cur.next
        cur.next = node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定位置添加元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def insert(self, pos, item):
    &amp;quot;&amp;quot;&amp;quot;指定位置添加元素&amp;quot;&amp;quot;&amp;quot;
    # 若指定位置pos为第一个元素之前，则执行头部插入
    if pos &amp;lt;= 0:
        self.add(item)
    # 若指定位置超过链表尾部，则执行尾部插入
    elif pos &amp;gt; (self.length() - 1):
        self.append(iteam)
    # 找到指定位置
    else:
        node = SingleNode(item)
        count = 0
        # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置
        pre = self._head
        while count &amp;lt; (pos - 1):
            count += 1
            pre = pre.next
        # 先将新节点node的next指向插入位置的节点
        node.next = pre.next
        # 将插入位置的前一个节点的next指向新节点
        pre.next = node

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def remove(self, item):
    &amp;quot;&amp;quot;&amp;quot;删除节点&amp;quot;&amp;quot;&amp;quot;
    cur = self._head
    pre = None
    while cur != None:
        # 找到了指定元素
        if cur.item == item:
            # 如果第一个就是删除的节点
            if not pre:
                # 将头指针指向头节点的后一个节点
                self._head = cur.next
            else:
                # 将删除位置前一个节点的next指向删除位置的后一个节点
                pre.next = cur.next
            break
        else:
            # 继续按链表后移节点
            pre = cur
            cur = cur.next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def search(self, item):
    &amp;quot;&amp;quot;&amp;quot;链表查找节点是否存在，并返回True或者False&amp;quot;&amp;quot;&amp;quot;
    cur = self._head
    while cur != None:
        if cur.item == item:
            return True
        cur = cur.next
    return False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单向循环链表&lt;/p&gt;

&lt;p&gt;单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。&lt;/p&gt;

&lt;p&gt;单向循环链表的操作&lt;/p&gt;

&lt;p&gt;is_empty() 判断链表是否为空
length() 返回链表的长度
travel() 遍历
add(item) 在头部添加一个节点
append(item) 在尾部添加一个节点
insert(pos, item) 在指定位置pos添加节点
remove(item) 删除一个节点
search(item) 查找节点是否存在&lt;/p&gt;

&lt;p&gt;单向循环链表实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Node(object):
    &amp;quot;&amp;quot;&amp;quot;节点&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, item):
        self.item = item
        self.next = None


class SinCycLinkedlist(object):
    &amp;quot;&amp;quot;&amp;quot;单向循环链表&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        self._head = None

    def is_empty(self):
        &amp;quot;&amp;quot;&amp;quot;判断链表是否为空&amp;quot;&amp;quot;&amp;quot;
        return self._head == None

    def length(self):
        &amp;quot;&amp;quot;&amp;quot;返回链表的长度&amp;quot;&amp;quot;&amp;quot;
        # 如果链表为空，返回长度0
        if self.is_empty():
            return 0
        count = 1
        cur = self._head
        while cur.next != self._head:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &amp;quot;&amp;quot;&amp;quot;遍历链表&amp;quot;&amp;quot;&amp;quot;
        if self.is_empty():
            return
        cur = self._head
        print cur.item,
        while cur.next != self._head:
            cur = cur.next
            print cur.item,
        print &amp;quot;&amp;quot;


    def add(self, item):
        &amp;quot;&amp;quot;&amp;quot;头部添加节点&amp;quot;&amp;quot;&amp;quot;
        node = Node(item)
        if self.is_empty():
            self._head = node
            node.next = self._head
        else:
            #添加的节点指向_head
            node.next = self._head
            # 移到链表尾部，将尾部节点的next指向node
            cur = self._head
            while cur.next != self._head:
                cur = cur.next
            cur.next = node
            #_head指向添加node的
            self._head = node

    def append(self, item):
        &amp;quot;&amp;quot;&amp;quot;尾部添加节点&amp;quot;&amp;quot;&amp;quot;
        node = Node(item)
        if self.is_empty():
            self._head = node
            node.next = self._head
        else:
            # 移到链表尾部
            cur = self._head
            while cur.next != self._head:
                cur = cur.next
            # 将尾节点指向node
            cur.next = node
            # 将node指向头节点_head
            node.next = self._head

    def insert(self, pos, item):
        &amp;quot;&amp;quot;&amp;quot;在指定位置添加节点&amp;quot;&amp;quot;&amp;quot;
        if pos &amp;lt;= 0:
            self.add(item)
        elif pos &amp;gt; (self.length()-1):
            self.append(item)
        else:
            node = Node(item)
            cur = self._head
            count = 0
            # 移动到指定位置的前一个位置
            while count &amp;lt; (pos-1):
                count += 1
                cur = cur.next
            node.next = cur.next
            cur.next = node

    def remove(self, item):
        &amp;quot;&amp;quot;&amp;quot;删除一个节点&amp;quot;&amp;quot;&amp;quot;
        # 若链表为空，则直接返回
        if self.is_empty():
            return
        # 将cur指向头节点
        cur = self._head
        pre = None
        # 若头节点的元素就是要查找的元素item
        if cur.item == item:
            # 如果链表不止一个节点
            if cur.next != self._head:
                # 先找到尾节点，将尾节点的next指向第二个节点
                while cur.next != self._head:
                    cur = cur.next
                # cur指向了尾节点
                cur.next = self._head.next
                self._head = self._head.next
            else:
                # 链表只有一个节点
                self._head = None
        else:
            pre = self._head
            # 第一个节点不是要删除的
            while cur.next != self._head:
                # 找到了要删除的元素
                if cur.item == item:
                    # 删除
                    pre.next = cur.next
                    return
                else:
                    pre = cur
                    cur = cur.next
            # cur 指向尾节点
            if cur.item == item:
                # 尾部删除
                pre.next = cur.next

    def search(self, item):
        &amp;quot;&amp;quot;&amp;quot;查找节点是否存在&amp;quot;&amp;quot;&amp;quot;
        if self.is_empty():
            return False
        cur = self._head
        if cur.item == item:
            return True
        while cur.next != self._head:
            cur = cur.next
            if cur.item == item:
                return True
        return False

if __name__ == &amp;quot;__main__&amp;quot;:
    ll = SinCycLinkedlist()
    ll.add(1)
    ll.add(2)
    ll.append(3)
    ll.insert(2, 4)
    ll.insert(4, 5)
    ll.insert(0, 6)
    print &amp;quot;length:&amp;quot;,ll.length()
    ll.travel()
    print ll.search(3)
    print ll.search(7)
    ll.remove(1)
    print &amp;quot;length:&amp;quot;,ll.length()
    ll.travel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双向循环链表&lt;/p&gt;

&lt;p&gt;        一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。&lt;/p&gt;

&lt;p&gt;双向循环链表的操作&lt;/p&gt;

&lt;p&gt;is_empty() 链表是否为空
length() 链表长度
travel() 遍历链表
add(item) 链表头部添加
append(item) 链表尾部添加
insert(pos, item) 指定位置添加
remove(item) 删除节点
search(item) 查找节点是否存在
双向循环链表的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Node(object):
    &amp;quot;&amp;quot;&amp;quot;双向链表节点&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, item):
        self.item = item
        self.next = None
        self.prev = None


class DLinkList(object):
    &amp;quot;&amp;quot;&amp;quot;双向链表&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        self._head = None

    def is_empty(self):
        &amp;quot;&amp;quot;&amp;quot;判断链表是否为空&amp;quot;&amp;quot;&amp;quot;
        return self._head == None

    def length(self):
        &amp;quot;&amp;quot;&amp;quot;返回链表的长度&amp;quot;&amp;quot;&amp;quot;
        cur = self._head
        count = 0
        while cur != None:
            count += 1
            cur = cur.next
        return count

    def travel(self):
        &amp;quot;&amp;quot;&amp;quot;遍历链表&amp;quot;&amp;quot;&amp;quot;
        cur = self._head
        while cur != None:
            print cur.item,
            cur = cur.next
        print &amp;quot;&amp;quot;

    def add(self, item):
        &amp;quot;&amp;quot;&amp;quot;头部插入元素&amp;quot;&amp;quot;&amp;quot;
        node = Node(item)
        if self.is_empty():
            # 如果是空链表，将_head指向node
            self._head = node
        else:
            # 将node的next指向_head的头节点
            node.next = self._head
            # 将_head的头节点的prev指向node
            self._head.prev = node
            # 将_head 指向node
            self._head = node

    def append(self, item):
        &amp;quot;&amp;quot;&amp;quot;尾部插入元素&amp;quot;&amp;quot;&amp;quot;
        node = Node(item)
        if self.is_empty():
            # 如果是空链表，将_head指向node
            self._head = node
        else:
            # 移动到链表尾部
            cur = self._head
            while cur.next != None:
                cur = cur.next
            # 将尾节点cur的next指向node
            cur.next = node
            # 将node的prev指向cur
            node.prev = cur



    def search(self, item):
        &amp;quot;&amp;quot;&amp;quot;查找元素是否存在&amp;quot;&amp;quot;&amp;quot;
        cur = self._head
        while cur != None:
            if cur.item == item:
                return True
            cur = cur.next
        return False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双向循环链表指定位置插入节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def insert(self, pos, item):
    &amp;quot;&amp;quot;&amp;quot;在指定位置添加节点&amp;quot;&amp;quot;&amp;quot;
    if pos &amp;lt;= 0:
        self.add(item)
    elif pos &amp;gt; (self.length() - 1):
        self.append(item)
    else:
        node = Node(item)
        cur = self._head
        count = 0
        # 移动到指定位置的前一个位置
        while count &amp;lt; (pos - 1):
            count += 1
            cur = cur.next
        # 将node的prev指向cur
        node.prev = cur
        # 将node的next指向cur的下一个节点
        node.next = cur.next
        # 将cur的下一个节点的prev指向node
        cur.next.prev = node
        # 将cur的next指向node
        cur.next = node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双向循环链表删除元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def remove(self, item):
    &amp;quot;&amp;quot;&amp;quot;删除元素&amp;quot;&amp;quot;&amp;quot;
    if self.is_empty():
        return
    else:
        cur = self._head
        if cur.item == item:
            # 如果首节点的元素即是要删除的元素
            if cur.next == None:
                # 如果链表只有这一个节点
                self._head = None
            else:
                # 将第二个节点的prev设置为None
                cur.next.prev = None
                # 将_head指向第二个节点
                self._head = cur.next
            return
        while cur != None:
            if cur.item == item:
                # 将cur的前一个节点的next指向cur的后一个节点
                cur.prev.next = cur.next
                # 将cur的后一个节点的prev指向cur的前一个节点
                cur.next.prev = cur.prev
                break
            cur = cur.next
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python链表操作</title>
      <link>/2019/python%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/python%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;p&gt;顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。&lt;/p&gt;

&lt;p&gt;链表的定义：
        链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。&lt;/p&gt;

&lt;p&gt;链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。
 注意：
 链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。&lt;/p&gt;

&lt;p&gt;1、创建一个链接
node1 = Node(&amp;ldquo;c&amp;rdquo;,node3)
或者
node1 = Node(&amp;ldquo;c&amp;rdquo;,None)
node1.next = node3
2、用循环创建一个链表结构，并且访问其中的每一个节点
class Node(object):
    def &lt;strong&gt;init&lt;/strong&gt;(self, data, next=None):
        self.data = data
        self.next = next&lt;/p&gt;

&lt;p&gt;head = None
for count in range(1,6):
    head = Node(count, head)
while head != None:
    print(head.data)
    head = head.next
3、遍历
     遍历使用一个临时的指针变量，这个变量先初始化为链表结构的head指针，然后控制一个循环。&lt;/p&gt;

&lt;p&gt;probe = head
while probe != None:
    probe = probe.next
4、搜索
     有两个终止条件：&lt;/p&gt;

&lt;p&gt;     一、空链表，不再有要检查的数据。&lt;/p&gt;

&lt;p&gt;     二、目标项等于数据项，成功找到。&lt;/p&gt;

&lt;p&gt;probe = head
while probe != None and targetItem != probe.data:
    probe = probe.next
if probe != None:
    print(&amp;ldquo;target is found&amp;rdquo;)
else:
    print(&amp;ldquo;target is not in this linked structure&amp;rdquo;)
5、访问链表中的第i（index）项
probe = head
while index &amp;gt; 0:
    probe = probe.next
    index -= 1
print(probe.data)
6、替换
      若目标项不存在，则返回False；否则替换相应的项，并返回True.&lt;/p&gt;

&lt;p&gt;probe = head
while probe != None and targetItem != probe.data:
    probe = probe.next
if probe != None:
    probe.data = newItem
    return True
else:
    return False
7、在开始处插入
head = Node(newItem, head)
8、在末尾处插入
     在单链表末尾插入一项必须考虑两点：&lt;/p&gt;

&lt;p&gt;     一、head指针为None，此时，将head指针设置为新的节点&lt;/p&gt;

&lt;p&gt;     二、head不为None，此时代码将搜索最后一个节点，并将其next指针指向新的节点。&lt;/p&gt;

&lt;p&gt;newNode = Node(newItem)
if head is None:
    head = newItem
else:
    probe = head
    while probe.next != None:
        probe = probe.next
    probe.next = newNode
9、从开始处删除
head = head.next
10、从末尾删除
       需要考虑两种情况：&lt;/p&gt;

&lt;p&gt;       一、只有一个节点，head指针设置为None&lt;/p&gt;

&lt;p&gt;       二、在最后一个节点之前没有节点，只需要倒数第二个节点的next指向None即可。&lt;/p&gt;

&lt;p&gt;if head.next is None:
    head = None
else:
    probe = head
    while probe.next.next != None:
        probe = probe.next
    probe.next = None
11、在任何位置插入
       需要考虑两种情况：&lt;/p&gt;

&lt;p&gt;       一、该节点的next指针为None。这意味着，i&amp;gt;=n，因此，应该将新的项放在链表结构的末尾。&lt;/p&gt;

&lt;p&gt;       二、该节点的next指针不为None，这意味着，0&amp;lt;i&amp;lt;n，因此需将新的项放在i-1和i之间。&lt;/p&gt;

&lt;p&gt;if head is None or index &amp;lt;=0:
    head =Node(newItem, head)
else:
    probe = head
    while index &amp;gt; 1 and probe.next != None:
        probe = probe.next
        index -= 1
    probe.next = Node(newItem, probe.next)
12、在任意位置删除
       一、i&amp;lt;= 0——使用删除第一项的代码&lt;/p&gt;

&lt;p&gt;       二、0&amp;lt;i&amp;lt;n——搜索位于i-1位置的节点，删除其后面的节点&lt;/p&gt;

&lt;p&gt;       三、i&amp;gt;n——删除最后一个节点&lt;/p&gt;

&lt;p&gt;if index &amp;lt;= 0 or head.next is None:
    head = head.next
else:
    probe = head
    while index &amp;gt; 1 and probe.next.next != None:
        probe = probe.next
        index -= 1
    probe.next = probe.next.next&lt;/p&gt;

&lt;p&gt;————————————————
版权声明：本文为CSDN博主「su_bao」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：&lt;a href=&#34;https://blog.csdn.net/su_bao/article/details/81065746&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/su_bao/article/details/81065746&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单链表反转</title>
      <link>/2019/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;p&gt;单链表结构
head &amp;mdash; node1 &amp;mdash; node2 &amp;mdash; node3 &amp;mdash; node4 &amp;mdash;- None&lt;/p&gt;

&lt;p&gt;反转实现
     建立三个变量，L、M、R互相赋值迭代，并建立指向关系，从而实现单链表的反转。
python代码实现
class Node(object):
    def &lt;strong&gt;init&lt;/strong&gt;(self, data, next=None):
        self.val = data
        self.next = next&lt;/p&gt;

&lt;p&gt;def fun4(head):
    if head == None:
        return None
    L,M,R = None,None,head
    while R.next != None:
        L = M
        M = R
        R = R.next
        M.next = L
    R.next = M
    return R
#测试用例
if &lt;strong&gt;name&lt;/strong&gt; == &amp;lsquo;&lt;strong&gt;main&lt;/strong&gt;&amp;lsquo;:
    l1 = Node(3)
    l1.next = Node(2)
    l1.next.next = Node(1)
    l1.next.next.next = Node(9)
    l = fun4(l1)
    print (l.val, l.next.val, l.next.next.val, l.next.next.next.val)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>聚焦爬虫和通用爬虫</title>
      <link>/2019/%E8%81%9A%E7%84%A6%E7%88%AC%E8%99%AB%E5%92%8C%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/</link>
      <pubDate>Thu, 08 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E8%81%9A%E7%84%A6%E7%88%AC%E8%99%AB%E5%92%8C%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/</guid>
      <description>&lt;p&gt;1.通用爬虫：搜索引擎用的爬虫系统。搜索引擎和供应商提供的爬虫。&lt;/p&gt;

&lt;p&gt;　通用爬虫要遵循规则：Robots协议
　
　通用爬虫工作流程：
　　爬取网页》存储数据》内容处理》提供检索
　
　通用爬虫缺点：
　　只能提供和文本相关的内容如html、world、pdf等，不能提供多媒体文件如音乐、图片、视频和二进制文件（脚本、程序）
　　提供的结果千篇一律，针对不同领域提供不同内容
　　不能提供人类语义上的检索
　
　通用爬虫局限性：
　　1.通用搜索引擎返回网页的数据内容，大概90%都无用。
　　2.中文搜索引擎自然语言检索理解困难。
　　3.信息占有量和覆盖率存在局限。
　　4.搜索引擎主要是以关键字搜索为主，对于图片、数据库、视频、音频等多媒体的内容用通用搜索引擎无效。
　　5.搜索引擎的社区化和个性化不好，未考虑实际因素如人的地域、性别、年龄等差别。
　　6.搜索引擎爬取动态网页效果不好&lt;/p&gt;

&lt;p&gt;2.聚焦爬虫：针对于某一需求编写的爬虫程序。
　
  聚焦爬虫可分为三类：
　　
　1.积累式爬虫：从开始到结束，不断爬取，过程会进行重复操作。&lt;/p&gt;

&lt;p&gt;　2.增量爬虫：已下载网页采取增量式跟新，爬取更新变化的数据。
　
　3.深度爬虫：指那些不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获取的web界面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多线程cpu/gil</title>
      <link>/2019/%E5%A4%9A%E7%BA%BF%E7%A8%8Bcpu%E4%B8%8Egil/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E5%A4%9A%E7%BA%BF%E7%A8%8Bcpu%E4%B8%8Egil/</guid>
      <description>&lt;p&gt;多线程与CPU：
1.单核CPU  CPU密集型的程序（做计算操作的程序）  单线程即可（ 此时的任务已经把CPU资源100%消耗了，就没必要也不可能使用多线程来提高计算效率）
2.单核CPU  IO密集型的程序（做IO操作的程序 ）        多线程&amp;gt;单线程（多线程可以阻塞，但并不是并行，是“伪并行”，实际上还是一个CPU在执行一切事物，只是切换的太快，没法察觉）
3.多核CPU 做计算操作的程序 多线程&amp;gt;&amp;gt;单线程 （每个核心执行一个线程，每个核心的线程并发执行计算，以提高任务执行效率，例如加密解密，数据压缩解压缩（视频、音频、普通数据），否则只能使一个核心满载，而其他核心闲置。）&lt;/p&gt;

&lt;p&gt;4.多核CPU  IO密集型任务 多线程&amp;gt;单线程&lt;/p&gt;

&lt;p&gt;但是在PYTHON里：&lt;/p&gt;

&lt;p&gt;由于GIL的机制就变得不完全一样了：单核CPU  CPU密集型程序 单线程耗时&amp;lt;多线程。多核CPU  CPU密集型程序 单线程耗时&amp;lt;多线程，也就是说只要是CPU密集型程序 不要只单独的使用多线程。&lt;/p&gt;

&lt;p&gt;一、先说为什么会有GIL ，GIL是干什么的：&lt;/p&gt;

&lt;p&gt;多线程之间数据完整性和状态同步的最简单方法自然就是加锁，于是python解释器有了GIL这把超级大锁，就默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作。&lt;/p&gt;

&lt;p&gt;也就是说 如果不释放这把锁，线程都是串行的。&lt;/p&gt;

&lt;p&gt;但PYTHON的多线程并不是一无是处&lt;/p&gt;

&lt;p&gt;二、GIL锁的释放机制：&lt;/p&gt;

&lt;p&gt;先解释什么是IO密集型和计算密集型：&lt;/p&gt;

&lt;p&gt;计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。&lt;/p&gt;

&lt;p&gt;计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。&lt;/p&gt;

&lt;p&gt;第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。&lt;/p&gt;

&lt;p&gt;IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。&lt;/p&gt;

&lt;p&gt;GIL对于IO密集型和计算密集型：&lt;/p&gt;

&lt;p&gt;IO密集型（网络传输、磁盘读写等）：
线程遇到I/O阻塞时，会自动释放GIL。（阻塞等待时，就释放GIL，给另一个线程执行的机会）&lt;/p&gt;

&lt;p&gt;cpu密集型（编解码，解压缩等）：
解释器会周期性的让线程释放锁&lt;/p&gt;

&lt;p&gt;由上面可知，至少有两种情况python会做线程切换，一是一但有IO操作时，会有线程切换，二是当一个线程连续执行了一定数量的指令时，会出现线程切换。&lt;/p&gt;

&lt;p&gt;再加上每次操作系统执行线程的调度都需要消耗时间，这样，就可以理解为什么在多核+cpu密集型程序时不要单独的使用多线程，会比单线程更耗时。&lt;/p&gt;

&lt;p&gt;即使是多核CPU，如果没有GIL 不同核的CPU执行不同的线程，但是有了GIL这把锁，某个核心上的CPU即使被唤醒也没有获得GIL锁，无法执行。&lt;/p&gt;

&lt;p&gt;在不使用别的库的情况下，python多线程最好只用于IO密集型的操作.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库优化</title>
      <link>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;一：优化说明
A：有数据表明，用户可以承受的最大等待时间为8秒。数据库优化策略有很多，设计初期，建立好的数据结构对于后期性能优化至关重要。因为数据库结构是系统的基石，基础打不好，使用各种优化策略，也不能达到很完美的效果。&lt;/p&gt;

&lt;p&gt;B：数据库优化的几个方面&lt;/p&gt;

&lt;p&gt;可以看出来，数据结构、SQL、索引是成本最低，且效果最好的优化手段。&lt;/p&gt;

&lt;p&gt;C：性能优化是无止境的，当性能可以满足需求时即可，不要过度优化。&lt;/p&gt;

&lt;p&gt;二：优化方向
1. SQL以及索引的优化
首先要根据需求写出结构良好的SQL，然后根据SQL在表中建立有效的索引。但是如果索引太多，不但会影响写入的效率，对查询也有一定的影响。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;合理的数据库是设计
根据数据库三范式来进行表结构的设计。设计表结构时，就需要考虑如何设计才能更有效的查询。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据库三范式：
第一范式：数据表中每个字段都必须是不可拆分的最小单元，也就是确保每一列的原子性；
第二范式：满足一范式后，表中每一列必须有唯一性，都必须依赖于主键；
第三范式：满足二范式后，表中的每一列只与主键直接相关而不是间接相关(外键也是直接相关)，字段没有冗余。&lt;/p&gt;

&lt;p&gt;注意：没有最好的设计，只有最合适的设计，所以不要过分注重理论。三范式可以作为一个基本依据，不要生搬硬套。&lt;/p&gt;

&lt;p&gt;有时候可以根据场景合理地反规范化：
A：分割表。
B：保留冗余字段。当两个或多个表在查询中经常需要连接时，可以在其中一个表上增加若干冗余的字段，以 避免表之间的连接过于频繁，一般在冗余列的数据不经常变动的情况下使用。
C：增加派生列。派生列是由表中的其它多个列的计算所得，增加派生列可以减少统计运算，在数据汇总时可以大大缩短运算时间。&lt;/p&gt;

&lt;p&gt;数据库五大约束：
A：PRIMARY key:设置主键约束；
B：UNIQUE：设置唯一性约束，不能有重复值；
C：DEFAULT 默认值约束
D：NOT NULL：设置非空约束，该字段不能为空；
E：FOREIGN key :设置外键约束。&lt;/p&gt;

&lt;p&gt;字段类型选择：
A：尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
B：VARCHAR的长度只分配真正需要的空间
C：使用枚举或整数代替字符串类型
D：尽量使用TIMESTAMP而非DATETIME
E：单表不要有太多字段，建议在20以内
F：避免使用NULL字段，很难查询优化且占用额外索引空间&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统配置的优化
例如：MySQL数据库my.cnf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;硬件优化
更快的IO、更多的内存。一般来说内存越大，对于数据库的操作越好。但是CPU多就不一定了，因为他并不会用到太多的CPU数量，有很多的查询都是单CPU。另外使用高的IO（SSD、RAID），但是IO并不能减少数据库锁的机制。所以说如果查询缓慢是因为数据库内部的一些锁引起的，那么硬件优化就没有什么意义。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三：优化方案
代码优化
之所以把代码放到第一位，是因为这一点最容易引起技术人员的忽视。很多技术人员拿到一个性能优化的需求以后，言必称缓存、异步、JVM等。实际上，第一步就应该是分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。有一些性能问题，完全是由于代码写的不合理，通过直接修改一下代码就能解决问题的，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等。&lt;/p&gt;

&lt;p&gt;举个栗子：
一个update操作，先查询出entity，再执行update，这样无疑多了一次数据库交互。还有一个问题，update语句可能会操作一些无需更新的字段。
​
我们可以将表单中涉及到的属性，以及updateTime，updateUser等赋值到entity，直接通过pdateByPrimaryKeySelective，去update特定字段。&lt;/p&gt;

&lt;p&gt;​​&lt;/p&gt;

&lt;p&gt;定位慢SQL，并优化
这是最常用、每一个技术人员都应该掌握基本的SQL调优手段（包括方法、工具、辅助系统等）。这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。&lt;/p&gt;

&lt;p&gt;SqlServer执行计划：
通过执行计划，我们能得到哪些信息：
A：哪些步骤花费的成本比较高
B：哪些步骤产生的数据量多，数据量的多少用线条的粗细表示，很直观
C：每一步执行了什么动作&lt;/p&gt;

&lt;p&gt;具体优化手段：
A：尽量少用（或者不用）sqlserver 自带的函数
select id from t where substring(name,1,3) = ’abc’
select id from t where datediff(day,createdate,’2005-11-30′) = 0
可以这样查询：
select id from t where name like ‘abc%’
select id from t where createdate &amp;gt;= ‘2005-11-30’ and createdate &amp;lt; ‘2005-12-1’&lt;/p&gt;

&lt;p&gt;B：连续数值条件，用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
C：Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗
D：尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型
E：不建议使用 select * from t ，用具体的字段列表代替“&lt;em&gt;”，不要返回用不到的任何字段。尽量避免向客户 端返回大数据量，若数据量过大，应该考虑相应需求是否合理
F：表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能
G：select count(&lt;/em&gt;) from table；这样不带任何条件的count会引起全表扫描
连接池调优
我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。&lt;/p&gt;

&lt;p&gt;​​&lt;/p&gt;

&lt;p&gt;合理使用索引
索引一般情况下都是高效的。但是由于索引是以空间换时间的一种策略，索引本身在提高查询效率的同时会影响插入、更新、删除的效率，频繁写的表不宜建索引。&lt;/p&gt;

&lt;p&gt;选择合适的索引列，选择在where，group by，order by，on从句中出现的列作为索引项，对于离散度不大的列没有必要创建索引。
主键已经是索引了，所以primay key 的主键不用再设置unique唯一索引&lt;/p&gt;

&lt;p&gt;索引类型
主键索引 （PRIMARY KEY）
唯一索引 （UNIQUE）
普通索引 （INDEX）
组合索引 （INDEX）
全文索引 （FULLTEXT）&lt;/p&gt;

&lt;p&gt;可以应用索引的操作符
大于等于
Between
IN
LIKE 不以 % 开头&lt;/p&gt;

&lt;p&gt;不能应用索引的操作符
NOT IN
LIKE %_ 开头&lt;/p&gt;

&lt;p&gt;如何选择索引字段
A：字段出现在查询条件中，并且查询条件可以使用索引
B：通常对数字的索引和检索要比对字符串的索引和检索效率更高
C：语句执行频率高，一天会有几千次以上
D：通过字段条件可筛选的记录集很小
​​&lt;/p&gt;

&lt;p&gt;无效索引
A：尽量不要在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
B：应尽量避免在 where 子句中使用 != 或 &amp;lt;&amp;gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。
C：应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
select id from t where num=10 or Name = ‘admin’
可以这样查询：
select id from t where num = 10
union
select id from t where Name = ‘admin’
union all 返回所有数据，不管是不是重复。 union会自动压缩，去除重复数据。&lt;/p&gt;

&lt;p&gt;D：不做列运算
where age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等
E：查询like，如果是 ‘%aaa’ 不会使用到索引&lt;/p&gt;

&lt;p&gt;分表
分表方式
水平分割（按行）、垂直分割(按列)&lt;/p&gt;

&lt;p&gt;分表场景
A： 根据经验，mysql表数据一般达到百万级别，查询效率就会很低。
B： 一张表的某些字段值比较大并且很少使用。可以将这些字段隔离成单独一张表，通过外键关联，例如考试成绩，我们通常关注分数，不关注考试详情。&lt;/p&gt;

&lt;p&gt;水平分表策略
按时间分表：当数据有很强的实效性，例如微博的数据，可以按月分割。
按区间分表：例如用户表 1到一百万用一张表，一百万到两百万用一张表。
hash分表：通过一个原始目标id或者是名称按照一定的hash算法计算出数据存储的表名。&lt;/p&gt;

&lt;p&gt;读写分离
当一台服务器不能满足需求时，采用读写分离【写: update/delete/add】的方式进行集群。
一台数据库支持最大连接数是有限的，如果用户的并发访问很多，一台服务器无法满足需求，可以集群处理。mysql集群处理技术最常用的就是读写分离。&lt;/p&gt;

&lt;p&gt;主从同步：数据库最终会把数据持久化到磁盘，集群必须确保每个数据库服务器的数据是一致的。从库读主库写，从库从主库上同步数据。
读写分离：使用负载均衡实现，写操作都往主库上写，读操作往从服务器上读。&lt;/p&gt;

&lt;p&gt;缓存
缓存分类
本地缓存：HashMap/ConcurrentHashMap、Ehcache、Guava Cache等
缓存服务：Redis/Tair/Memcache等&lt;/p&gt;

&lt;p&gt;使用场景
短时间内相同数据重复查询多次且数据更新不频繁，这个时候可以选择先从缓存查询，查询不到再从数据库加载并回设到缓存的方式。此种场景较适合用单机缓存。
高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛。&lt;/p&gt;

&lt;p&gt;缓存作用
减轻数据库的压力，减少访问时间。&lt;/p&gt;

&lt;p&gt;缓存选择
如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以选择本地缓存。具体的话，如果需要一些策略的支持（比如缓存满的逐出策略），可以考虑Ehcache；如不需要，可以考虑HashMap；如需要考虑多线程并发的场景，可以考虑ConcurentHashMap。
其他情况，可以考虑缓存服务。目前从资源的投入度、可运维性、是否能动态扩容以及配套设施来考虑，我们优先考虑Tair。除非目前Tair还不能支持的场合（比如分布式锁、Hash类型的value），我们考虑用Redis。&lt;/p&gt;

&lt;p&gt;缓存穿透
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比
如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造
成很大的压力。这就叫做缓存穿透。&lt;/p&gt;

&lt;p&gt;对查询结果为空的情况也进行缓存，缓存时间设置短点，或者该key对应的数据insert了之后清理缓存。&lt;/p&gt;

&lt;p&gt;缓存并发
有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，
如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。&lt;/p&gt;

&lt;p&gt;对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就
等待，然后等解锁后返回数据或者进入DB查询。&lt;/p&gt;

&lt;p&gt;缓存雪崩(失效)
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)
带来很大压力。
不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀.&lt;/p&gt;

&lt;p&gt;防止缓存空间不够用
① 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。
② 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。
③ 给一些没有必要长期保存的key，尽量设置过期时间。&lt;/p&gt;

&lt;p&gt;我们看下图，在WebServer（Dao层）和DB之间加一层cache，这层cache一般选取的介质是内存，因为我们都知道存入数据库的数据都具有持久化的特点，那么读写会有磁盘IO的操作，内存的读写速度远比磁盘快得多。（选用存储介质，提高访问速度：内存&amp;gt;&amp;gt;磁盘；减少磁盘IO的操作，减少重复查询，提高吞吐量）&lt;/p&gt;

&lt;p&gt;​​&lt;/p&gt;

&lt;p&gt;常用开源的缓存工具有：ehcache、memcache、redis。&lt;/p&gt;

&lt;p&gt;ehcache 是一个纯Java的进程内缓存框架，hibernate使用其做二级缓存。同时，ehcache可以通过多播的方式实现集群。本人主要用于本地的缓存，数据库上层的缓存。
memcache是一套分布式的高速缓存系统，提供key-value这样简单的数据储存，可充分利用CPU多核，无持久化功能。在做web集群中可以用做session共享，页面对象缓存。
redis高性能的key-value系统，提供丰富的数据类型，单核CPU有抗并发能力，有持久化和主从复制的功能。本人主要使用redis的redis sentinel，根据不同业务分为多组。&lt;/p&gt;

&lt;p&gt;redis注意事项
A：在增加 key 的时候尽量设置过期时间，不然 Redis Server 的内存使用会达到系统物理内存的最大值，导致 Redis 使用 VM 降低系统性能；
B：Redis Key 设计时应该尽可能短,Value 尽量不要使用复杂对象；
C：将对象转换成 JSON 对象（利用现成的 JSON 库）后存入 Redis；
D：将对象转换成 Google 开源二进制协议对象（Google Protobuf，和 JSON 数据格式类似，但是因为是二进制表现，所以性能效率以及空间占用都比 JSON 要小；缺点是 Protobuf 的学习曲线比 JSON 大得多）；
E：Redis 使用完以后一定要释放连接。&lt;/p&gt;

&lt;p&gt;读取缓存中是否有相关数据，如果缓存中有相关数据，则直接返回，这就是所谓的数据命中“hit”
如果缓存中没有相关数据，则从数据库读取相关数据，放入缓存中，再返回。这就是所谓的数据未命中“miss”&lt;/p&gt;

&lt;p&gt;缓存的命中率 = 命中缓存请求个数/总缓存访问请求个数 = hit/(hit+miss)
​​&lt;/p&gt;

&lt;p&gt;NoSQL
与缓存的区别
先说明一下，这里介绍的和缓存不一样，虽然redis等也可以用来做数据存储方案（比如Redis或者Tair），但NoSql是把它作为DB来用。如果当作DB来用，需要有效保证数据存储方案的可用性、可靠性。&lt;/p&gt;

&lt;p&gt;使用场景
需要结合具体的业务场景，看这块业务涉及的数据是否适合用NoSQL来存储，对数据的操作方式是否适合用NoSQL的方式来操作，或者是否需要用到NoSQL的一些额外特性（比如原子加减等）。
如果业务数据不需要和其他数据作关联，不需要事务或者外键之类的支持，而且有可能写入会异常频繁，这个时候就比较适合用NoSQL（比如HBase）。
比如，美团点评内部有一个对exception做的监控系统，如果在应用系统发生严重故障的时候，可能会短时间产生大量exception数据，这个时候如果选用MySQL，会造成MySQL的瞬间写压力飙升，容易导致MySQL服务器的性能急剧恶化以及主从同步延迟之类的问题，这种场景就比较适合用Hbase类似的NoSQL来存储。
视图/存储过程
普通业务逻辑尽量不要使用存储过程，定时任务或报表统计函数可以根据团队资源情况采用存储过程处理。&lt;/p&gt;

&lt;p&gt;GVM调优
通过监控系统（如没有现成的系统，自己做一个简单的上报监控的系统也很容易）上对一些机器关键指标（gc time、gc count、各个分代的内存大小变化、机器的Load值与CPU使用率、JVM的线程数等）的监控报警，也可以看gc log和jstat等命令的输出，再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，基本上就能定位出当前的JVM是否有问题，以及是否需要调优。&lt;/p&gt;

&lt;p&gt;异步/多线程
针对某些客户端的请求，在服务端可能需要针对这些请求做一些附属的事情，这些事情其实用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式处理这些事情。&lt;/p&gt;

&lt;p&gt;异步作用
A：缩短接口响应时间，使用户的请求快速返回，用户体验更好。
B：避免线程长时间处于运行状态，这样会引起服务线程池的可用线程长时间不够用，进而引起线程池任务队列长度增大，从而阻塞更多请求任务，使得更多请求得不到技术处理。
C：线程长时间处于运行状态，可能还会引起系统Load、CPU使用率、机器整体性能下降等一系列问题，甚至引发雪崩。异步的思路可以在不增加机器数和CPU数的情况下，有效解决这个问题。&lt;/p&gt;

&lt;p&gt;异步实现
A：额外开辟线程，这里可以采用额外开辟一个线程或者使用线程池的做法，在IO线程（处理请求响应）之外的线程来处理相应的任务，在IO线程中让response先返回。
B：使用消息队列（MQ）中间件服务&lt;/p&gt;

&lt;p&gt;搜索引擎
例如：solr，elasticsearch
————————————————
版权声明：本文为CSDN博主「十五楼亮哥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：&lt;a href=&#34;https://blog.csdn.net/u013628152/article/details/82184809&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/u013628152/article/details/82184809&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库sql优化</title>
      <link>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;

&lt;p&gt;2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num is null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.&lt;/p&gt;

&lt;p&gt;备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。&lt;/p&gt;

&lt;p&gt;不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。&lt;/p&gt;

&lt;p&gt;可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.应尽量避免在 where 子句中使用 != 或 &amp;lt;&amp;gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。&lt;/p&gt;

&lt;p&gt;4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num=10 or Name = &#39;admin&#39;
可以这样查询：

select id from t where num = 10
union all
select id from t where Name = &#39;admin&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.in 和 not in 也要慎用，否则会导致全表扫描，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num in(1,2,3)
对于连续的数值，能用 between 就不要用 in 了：

select id from t where num between 1 and 3
很多时候用 exists 代替 in 是一个好的选择：

select num from a where num in(select num from b)
用下面的语句替换：

select num from a where exists(select 1 from b where num=a.num)
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.下面的查询也将导致全表扫描：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where name like ‘%abc%’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要提高效率，可以考虑全文检索。&lt;/p&gt;

&lt;p&gt;7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num = @num
可以改为强制查询使用索引：

select id from t with(index(索引名)) where num = @num
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where num/2 = 100

应改为:
select id from t where num = 100*2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where substring(name,1,3) = ’abc’       -–name以abc开头的id
select id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应改为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select id from t where name like &#39;abc%&#39;
select id from t where createdate &amp;gt;= &#39;2005-11-30&#39; and createdate &amp;lt; &#39;2005-12-1&#39;
``
10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

12.不要写一些没有意义的查询，如需要生成一个空表结构：

select col1,col2 into #t from t where 1=0
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：
create table #t(…)

13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。

14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。

15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。


16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。

18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

20.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。

23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。

29.尽量避免大事务操作，提高系统并发能力。

30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

 

实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句
　　如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。
　　Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。
　　如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。
　　所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;`
while(1){&lt;/p&gt;

&lt;p&gt;　　//每次只做1000条&lt;/p&gt;

&lt;p&gt;　　 mysql_query(“delete from logs where log_date &amp;lt;= ’2012-11-01’ limit 1000”);&lt;/p&gt;

&lt;p&gt;　　if(mysql_affected_rows() == 0){&lt;/p&gt;

&lt;p&gt;　　 　　//删除完成，退出！
　　 　　break；
　　}&lt;/p&gt;

&lt;p&gt;//每次暂停一段时间，释放表让其他进程/线程访问。
usleep(50000)&lt;/p&gt;

&lt;p&gt;}
&lt;code&gt;
&lt;/code&gt;``&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>爬虫逆向工程</title>
      <link>/2019/%E7%88%AC%E8%99%AB%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/%E7%88%AC%E8%99%AB%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;爬虫篇：动态网页的处理方式（上）——逆向工程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/ha_hha/article/details/80324343&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/ha_hha/article/details/80324343&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.简谈-Python爬虫破解JS加密的Cookie&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zccpython/p/6886634.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/zccpython/p/6886634.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.运用phantomjs无头浏览器破解四种反爬虫技术&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://python.jobbole.com/86415/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://python.jobbole.com/86415/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.Python爬虫教程-16-破解js加密实例（有道在线翻译）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_40147863/article/details/82079649&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/qq_40147863/article/details/82079649&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python面试题收藏</title>
      <link>/2019/python%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/python%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;p&gt;git上的面试题
 &lt;a href=&#34;https://github.com/kenwoodjw/python_interview_question&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/kenwoodjw/python_interview_question&lt;/a&gt;
 &lt;a href=&#34;https://github.com/taizilongxu/interview_python&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/taizilongxu/interview_python&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一些简单的Python测试题
&lt;a href=&#34;http://www.wklken.me/posts/2015/08/26/python-some-test-questions.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.wklken.me/posts/2015/08/26/python-some-test-questions.html&lt;/a&gt;
&lt;a href=&#34;https://baijiahao.baidu.com/s?id=1607651363840614527&amp;amp;wfr=spider&amp;amp;for=pc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://baijiahao.baidu.com/s?id=1607651363840614527&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;面试Python后端的技巧
 &lt;a href=&#34;https://blog.csdn.net/yueguanghaidao/article/details/49638261&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/yueguanghaidao/article/details/49638261&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个python面试经历
 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU0ODczMTEwOQ==&amp;amp;mid=2247486666&amp;amp;idx=1&amp;amp;sn=709653e9cb60ca65ea6636bf7cdd8381&amp;amp;source=41#wechat_redirect&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://mp.weixin.qq.com/s?__biz=MzU0ODczMTEwOQ==&amp;amp;mid=2247486666&amp;amp;idx=1&amp;amp;sn=709653e9cb60ca65ea6636bf7cdd8381&amp;amp;source=41#wechat_redirect&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx的启动与安装</title>
      <link>/2019/nginx%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/nginx%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h1 id=&#34;启动&#34;&gt;启动&lt;/h1&gt;

&lt;p&gt;启动代码格式：nginx安装目录地址 -c nginx配置文件地址&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;[root@LinuxServer sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf&lt;/p&gt;

&lt;h1 id=&#34;停止&#34;&gt;停止&lt;/h1&gt;

&lt;p&gt;nginx的停止有三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;## 从容停止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　1、查看进程号&lt;/p&gt;

&lt;p&gt;[root@LinuxServer ~]# ps -ef|grep nginx&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/01.png&#34; alt=&#34;查看进程号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　2、杀死进程&lt;/p&gt;

&lt;p&gt;[root@LinuxServer ~]# kill -QUIT 2072&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/kill.png&#34; alt=&#34;杀死进程&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;## 快速停止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1、查看进程号&lt;/p&gt;

&lt;p&gt;[root@LinuxServer ~]# ps -ef|grep nginx&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/02.png&#34; alt=&#34;查看进程号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2、杀死进程&lt;/p&gt;

&lt;p&gt;[root@LinuxServer ~]# kill -TERM 2132
或 [root@LinuxServer ~]# kill -INT 2132&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/03.png&#34; alt=&#34;杀死进程&#34; /&gt;
- ## 强制停止&lt;/p&gt;

&lt;p&gt;[root@LinuxServer ~]# pkill -9 nginx&lt;/p&gt;

&lt;h1 id=&#34;重启&#34;&gt;重启&lt;/h1&gt;

&lt;h2 id=&#34;1-验证nginx配置文件是否正确&#34;&gt;1、验证nginx配置文件是否正确&lt;/h2&gt;

&lt;h3 id=&#34;方法一-进入nginx安装目录sbin下-输入命令-nginx-t&#34;&gt;方法一：进入nginx安装目录sbin下，输入命令./nginx -t&lt;/h3&gt;

&lt;p&gt;看到如下显示nginx.conf syntax is ok&lt;/p&gt;

&lt;p&gt;nginx.conf test is successful&lt;/p&gt;

&lt;p&gt;说明配置文件正确！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;方法二-在启动命令-c前加-t&#34;&gt;方法二：在启动命令-c前加-t&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/05.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-重启nginx服务&#34;&gt;2、重启Nginx服务&lt;/h2&gt;

&lt;h3 id=&#34;方法一-进入nginx可执行目录sbin下-输入命令-nginx-s-reload-即可&#34;&gt;方法一：进入nginx可执行目录sbin下，输入命令&lt;strong&gt;./nginx -s reload&lt;/strong&gt; 即可&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/images/xm/06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;方法二-查找当前nginx进程号-然后输入命令-kill-hup-进程号-实现重启nginx服务&#34;&gt;方法二：查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Mysql的一些报错</title>
      <link>/2019/mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99/</guid>
      <description>

&lt;h1 id=&#34;mysql-连接错误can-t-connect-to-mysql-server-on-61-https-www-cnblogs-com-xinjie10001-p-6279255-html&#34;&gt;&lt;a href=&#34;https://www.cnblogs.com/xinjie10001/p/6279255.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MySQL 连接错误Can&amp;rsquo;t connect to MySQL server on (61)&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;链接数据库时忽然遇到一个问题。Mac Navicat链接时报错Can’t connect to MySQL server on ‘xx.xx.xx.xx’ (61)。&lt;/p&gt;

&lt;p&gt;PS. win版Navicat 报错Can’t connect to MySQL server on ‘xx.xx.xx.xx’ (10038)&lt;/p&gt;

&lt;p&gt;其中xx.xx.xx.xx是ip地址。&lt;/p&gt;

&lt;h3 id=&#34;1-查看该用户是否有远程登录的权限&#34;&gt;1、查看该用户是否有远程登录的权限&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mysql&amp;gt; SELECT * FROM mysql.user;
+-----------+-----------+
| User | Host |
+-----------+-----------+
| M | % |
| mysql.sys | localhost |
| root | localhost |
| tommy | ％ |
| showhilllee | ％ |
+-----------+-----------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很显然，M是允许从其它服务器登陆的。&lt;/p&gt;

&lt;h3 id=&#34;2-查看-mysql-server-是不是监听了-3306-端口&#34;&gt;2、查看 MySQL Server 是不是监听了 3306 端口&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;执行命令&lt;code&gt;netstat -tulpen&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;netstat -tulpen

Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State User Inode PID/Program name
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 0 16801 1507/sshd
tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 0 17222 1970/master
tcp6 0 0 :::3306 :::* LISTEN 27 46396 22054/mysqld
tcp6 0 0 :::22 :::* LISTEN 0 16803 1507/sshd
tcp6 0 0 ::1:25 :::* LISTEN 0 17223 1970/master
udp 0 0 0.0.0.0:68 0.0.0.0:* 0 49600 22999/dhclient
udp 0 0 0.0.0.0:43504 0.0.0.0:* 0 48850 22999/dhclient
udp6 0 0 :::47875 :::* 0 48851 22999/dhclient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在这里也没有问题。&lt;/p&gt;

&lt;p&gt;这里如果没有监听3306端口或者只监听了&lt;code&gt;localhost&lt;/code&gt;（0.0.0.0表示监听所有），则在&lt;code&gt;my.cnf&lt;/code&gt;添加下面这一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;bind-address = 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-如果服务器是-centos7-将-mysql-服务加入防火墙&#34;&gt;3、如果服务器是 CentOS7，将 MySQL 服务加入防火墙&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;执行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sudo firewall-cmd --zone=public --permanent --add-service=mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回success。然后继续执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sudo systemctl restart firewalld
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>scrapy是什么</title>
      <link>/2018/scrapy%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/scrapy%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;p&gt;Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架。&lt;/p&gt;

&lt;p&gt;Scrapy 常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;/p&gt;

&lt;p&gt;通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。&lt;/p&gt;

&lt;p&gt;Scrapy架构图(绿线是数据流向)&lt;/p&gt;

&lt;p&gt;Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。&lt;/p&gt;

&lt;p&gt;Scheduler(调度器): 它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。&lt;/p&gt;

&lt;p&gt;Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，&lt;/p&gt;

&lt;p&gt;Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器).&lt;/p&gt;

&lt;p&gt;Item Pipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。&lt;/p&gt;

&lt;p&gt;Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件。&lt;/p&gt;

&lt;p&gt;Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>正向路由与普通路由</title>
      <link>/2018/%E6%AD%A3%E5%90%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%99%AE%E9%80%9A%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/%E6%AD%A3%E5%90%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%99%AE%E9%80%9A%E8%B7%AF%E7%94%B1/</guid>
      <description>

&lt;h3 id=&#34;什么是路由&#34;&gt;什么是路由？&lt;/h3&gt;

&lt;p&gt;​   URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应。&lt;/p&gt;

&lt;p&gt;在项目中编写路由，就是向外暴露我们接收哪些URL的请求，除此之外的任何URL都不被处理，也没有返回。通俗地理解，不恰当的形容，URL路由是你的Web服务对外暴露的API。&lt;/p&gt;

&lt;p&gt;django使用反向解析需要添加应用的命名空间，例如上图的 app_name = “booktest” booktest是你应用的名字
使用反向解析需要在url匹配后添加自己定义的name&lt;/p&gt;

&lt;p&gt;反向解析传递参数空格就行，这里的2就表示需要传递的参数，booktest就是你当前的这个应用的名字，fortest2就是你需要之前定义的名字&lt;/p&gt;

&lt;h3 id=&#34;什么是正则路由&#34;&gt;什么是正则路由？&lt;/h3&gt;

&lt;p&gt;在开发过程中，可能会出现限制用户访问规则的场景，那么这个时候就需要用到正则匹配，根据自己的规则去限定请求参数再进行访问。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;url(r&amp;rsquo;^index&amp;rsquo;,views.index) #默认的                  url(r&amp;rsquo;^home&amp;rsquo;,views.Home.as_view()) # CBV 形式 也就是说 class&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;url(r&amp;rsquo;^detail-(\d+).html&amp;rsquo;, views.detail),       # 在views里 def  home(request, nid, uid) 这两个参数不能调换循序&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;### # http: //www.baidu.com/detail-2-8.html   2是nid   8是uid&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;url (r&amp;rsquo;^detail-(?P&amp;lt; nid&amp;gt;\d+)-(?P&amp;lt; uid&amp;gt;\d+) .html&amp;rsquo;, views.detail)   #多个正则  在views里 def  home(request, nid, uid) 这两个参数可以没有顺序&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;什么情况下使用反向解析&#34;&gt;什么情况下使用反向解析？&lt;/h3&gt;

&lt;p&gt;所谓反向解析就是根据命名来调到指定的页面，这里表示的是跳转到booktest模板下面的fortest2这个视图里面， 而这个fortest2正是我们定义的名字，后面的2表示需要传递过去的参数&lt;/p&gt;

&lt;h2 id=&#34;一-urls硬编码&#34;&gt;一、urls硬编码&lt;/h2&gt;

&lt;p&gt;在反向解析和命名空间之前我们先来说说URLS硬编码，用django 开发应用的时候，可以完全是在urls.py 中硬编码配置地址,在views.py中HttpResponseRedirect()也是硬编码转向地址，当然在template 中也是一样了，这样带来一个问题，如果在urls.py 中修改了某个页面的地址（也就是说更改路由系统中对应的路由分发），那么所有的地方(views.py和template中)都要修改。问题出在硬编码，紧耦合使得在大量的模板中修改 URLs 成为富有挑战性的项目。来看下面的模板文件index.html中，我们到的链接硬编码成这样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/goods/index/&amp;quot;&amp;gt;url硬编码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用软编码之后，无论怎么更改路由系统中的路由分发，只有对应的namespace与name属性值不变，就不必修改在views.py和template中的url，也就是说&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;{% url &amp;quot;good:index&amp;quot; %}&amp;quot;&amp;gt;url软编码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在templates中更改为软编码之后，其实在templates，index.html文件生成的时候，仍然是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/goods/index/&amp;quot;&amp;gt;url软编码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-url的反向解析&#34;&gt;二、URL的反向解析&lt;/h2&gt;

&lt;p&gt;在使用Django 项目时，一个常见的需求是获得URL 的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。
人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。&lt;/p&gt;

&lt;p&gt;获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。
Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它：
1、根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。
2、根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。&lt;/p&gt;

&lt;p&gt;第一种方式是我们常说的&lt;strong&gt;根据地址定位URL。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第二种方式叫做&lt;strong&gt;反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查：
1、在模板中：使用url 模板标签。
2、在Python 代码中：使用 django.core.urlresolvers.&lt;strong&gt;reverse()&lt;/strong&gt; 函数。
3、在更高层的与处理Django 模型实例相关的代码中：使用 get_absolute_url() 方法。&lt;/p&gt;

&lt;h3 id=&#34;1-命名空间&#34;&gt;1、命名空间：&lt;/h3&gt;

&lt;p&gt;URL 命名空间允许你反查到唯一的命名URL 模式，即使不同的应用使用相同的URL 名称。第三方应用始终使用带命名空间的URL 是一个很好的实践。类似地，它还允许你在一个应用有多个实例部署的情况下反查URL。换句话讲，因为一个应用的多个实例共享相同的命名URL，命名空间将提供一种区分这些命名URL 的方法。&lt;/p&gt;

&lt;p&gt;一个URL 命名空间有两个部分，它们都是字符串：&lt;/p&gt;

&lt;h4 id=&#34;1-应用命名空间&#34;&gt;&lt;1&gt;、应用命名空间:&lt;/h4&gt;

&lt;p&gt;它表示正在部署的应用的名称。一个应用的每个实例具有相同的应用命名空间。例如，可以预见Django 的管理站点的应用命名空间是&amp;rsquo; admin &amp;lsquo;。&lt;/p&gt;

&lt;h4 id=&#34;2-实例命名空间&#34;&gt;&lt;2&gt;、实例命名空间:&lt;/h4&gt;

&lt;p&gt;它表示应用的一个特定的实例。实例的命名空间在你的全部项目中应该是唯一的。但是，一个实例的命名空间可以和应用的命名空间相同。它用于表示一个应用的默认实例。例如，Django 管理站点实例具有一个默认的实例命名空间&amp;rsquo;admin&amp;rsquo;。 URL的命名空间使用&amp;rsquo;:&amp;rsquo; 操作符指定。例如，管理站点应用的主页使用&amp;rsquo; admin:index &amp;lsquo;。它表示&amp;rsquo; admin &amp;lsquo; 的一个命名空间和&amp;rsquo; index &amp;lsquo; 的一个命名URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;＃ include函数的API
include(arg, namespace=None, app_name=None)
＃ namespace设置实例命名空间，app_name设置应用命名空间
＃ 不能只设置app_name，否则会报错，以下是报错的源码
if app_name and not namespace:
    raise ValueError(&#39;Must specify a namespace if specifying app_name.&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说，同一应用下的不同实例应该具有相同的应用命名空间，但是，这并不意味着不同应用可以使用相同的实例命名空间，因为实例命名空间在你所有项目中都是唯一的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt; 另外在添加命名空间 namespace时可能会出现以下这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    &#39;Specifying a namespace in include() without providing an app_name &#39;
django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案为：&lt;/p&gt;

&lt;p&gt;在对应的app应用的urls.py中添加app_name = &amp;lsquo;[应用名称]&amp;lsquo;如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.conf.urls import url
from . import views

app_name = &#39;users&#39;
# users为当前应用的名称

urlpatterns = [
    url(&#39;^$&#39;, views.index),
    url(&#39;^(\d+)/$&#39;, views.detail),
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;反向解析&#34;&gt;反向解析&lt;/h3&gt;

&lt;p&gt;1.定义：&lt;/p&gt;

&lt;p&gt;​   随着功能的增加会出现更多的视图，可能之前配置的正则表达式不够准确，于是就要修改正则表达式，但是正则表达式一旦修改了，之前所有对应的超链接都要修改，真是一件麻烦的事情，而且可能还会漏掉一些超链接忘记修改，有办法让链接根据正则表达式动态生成吗？ 就是用反向解析的办法。&lt;/p&gt;

&lt;p&gt;2.应用范围：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模板中的超链接&lt;/li&gt;
&lt;li&gt;视图中的重定向&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.使用方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义url时，需要为include定义namespace属性(就是命名空间)，为url定义name属性&lt;/li&gt;
&lt;li&gt;使用时，在模板中使用url标签，在视图中使用reverse函数，根据正则表达式动态生成地址，减轻后期维护成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-视图中的重定向&#34;&gt;4,视图中的重定向：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from django.shortcuts import redirect
from django.core.urlresolvers import reverse

return redirect(reverse(&#39;booktest:fan2&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-反向解析中url的参数&#34;&gt;5,反向解析中URL的参数&lt;/h2&gt;

&lt;p&gt;位置参数&lt;/p&gt;

&lt;p&gt;1）在booktest/urls.py中，修改fan2如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;url(r’^fan(\d+)_(\d+)/$’, views.fan2,name=’fan2’),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）修改templates/booktest/fan1.html文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;反向解析&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
普通链接：&amp;lt;a href=&amp;quot;/fan2_3/&amp;quot;&amp;gt;fan2&amp;lt;/a&amp;gt;
&amp;lt;hr&amp;gt;
反向解析：&amp;lt;a href=&amp;quot;{%url &#39;booktest:fan2&#39; 2 3%}&amp;quot;&amp;gt;fan2&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）回到浏览器中，刷新：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用重定向传递位置参数格式如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;return redirect(reverse(‘booktest:fan’, args=(2,3)))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关键字参数&lt;/p&gt;

&lt;p&gt;1）在booktest/urls.py中，修改fan2如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt; url(r&#39;^fan(?P&amp;lt;id&amp;gt;\d+)_(?P&amp;lt;age&amp;gt;\d+)/$&#39;, views.fan2,name=&#39;fan2&#39;),
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）修改templates/booktest/fan1.html文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;反向解析&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
普通链接：&amp;lt;a href=&amp;quot;/fan100_18/&amp;quot;&amp;gt;fan2&amp;lt;/a&amp;gt;
&amp;lt;hr&amp;gt;
反向解析：&amp;lt;a href=&amp;quot;{%url &#39;booktest:fan2&#39; id=100 age=18%}&amp;quot;&amp;gt;fan2&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）回到浏览器中，刷新：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用重定向传递关键字参数格式如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;return redirect(reverse(‘booktest:fan2’, kwargs={‘id’:110,’age’:26}))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;最后加一点自己的理解&#34;&gt;最后加一点自己的理解：&lt;/h4&gt;

&lt;p&gt;感觉反向解析其实也是也是对路由的运用，只不过区别在于更加的灵活，首先，要对主路由增加命名空间，对app里面的路由加上别名（即是给name赋值），然后无论是在view视图中的反定向也好，模板中的反向解析也好，都是在用命名空间和别名来操作的，无论路由中的正则表达式怎么变化，都不会影响到别名，也就是说别名是固定的，改变正则表达式时别名不变，这样就无需改变代码里用到的路由的地方，否则就要花很大的功夫来修改里面的每一个。&lt;/p&gt;

&lt;p&gt;注意:一点就是关于在路由中传参的操作，想要在路由中传参一定要记得修改正则表达式&lt;/p&gt;

&lt;p&gt;所谓反向解析就是根据命名来调到指定的页面，这里表示的是跳转到booktest模板下面的fortest2这个视图里面， 而这个fortest2正是我们定义的名字，后面的2表示需要传递过去的参数&lt;/p&gt;

&lt;p&gt;1.django使用反向解析需要添加应用的命名空间,需要在url匹配后添加自己定义的name&lt;/p&gt;

&lt;p&gt;2.反向解析传递参数空格就行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;{% url &#39;booktest:fortest2&#39; 2 %}&amp;quot; rel=&amp;quot;external nofollow&amp;quot; rel=&amp;quot;external nofollow&amp;quot; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.这样一来通过命名空间，无论在templates文件中有多庞大的url地址映射，只要使用url软编码，在更改路由系统的时候，都能自动生成。而如果使用硬链接硬编码 ，就只能在views.py和静态文件中逐个修改url地址，不仅耗费时间，更容易产生错误。&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————&lt;/p&gt;

&lt;h5 id=&#34;什么是路由-路由是用来干什么的&#34;&gt;什么是路由？路由是用来干什么的？&lt;/h5&gt;

&lt;p&gt;对一个给定的url进行定义，转换，传参，命名之后，找到相应处理函数的过程，也就是关联URL和处理函数的过程。&lt;/p&gt;

&lt;h5 id=&#34;那么路由流程是什么&#34;&gt;那么路由流程是什么？&lt;/h5&gt;

&lt;p&gt;1.查找全局路由文件中的urlpatterns变量&lt;/p&gt;

&lt;p&gt;2.根据先后顺序，对URL逐一匹配urlpatterns中的元素。&lt;/p&gt;

&lt;p&gt;3.找到第一个匹配的元素后，&lt;strong&gt;将停止查找&lt;/strong&gt;，并根据匹配结果执行处理函数。&lt;/p&gt;

&lt;p&gt;4.如果没有找到匹配，或者出现异常。Django将进行错误处理。&lt;/p&gt;

&lt;h5 id=&#34;django的路由配置&#34;&gt;django的路由配置&lt;/h5&gt;

&lt;p&gt;在settings.py文件中ROOT_URLCONF变量指定了全局路由文件名称。也就是工程的入口路由文件。&lt;/p&gt;

&lt;p&gt;ROOT_URLCONF = &amp;ldquo;&amp;lt;工程名称&amp;gt;.urls&amp;rdquo;
在urls.py文件中使用urlpatterns变量表示路由，该变量是列表类型，元素由path()或re_path()组成。&lt;/p&gt;

&lt;p&gt;path()处理字符串路由。re_path()处理正则表达式路由。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>